//Arquitectura
//Para este proyecto se trabajará/organizará con base a MVVM y Clean Architecture
//"MVVM" es un patrón de diseño de aruitectura, es "Model View ViewModel", donde "Model" son los datos o de donde se recolectan (como APIs, BD, etc.), "View" es la parte visual (las pantallas donde se muestra la información) y "ViewModel" es el enlace entre estas dos, el que trae la información del Model y lo coloca en el View (como un Controller en MVC)
//"Clean Architecture" es un patrón de diseño de arquitectura, indica como debemos organizar el proyecto (capas/carpetas), para qué es cada archivo y así
//En carpeta "domain" va la lógica del negocio, ahí no debe estar en un solo lenguaje en especifíco sino que debe ser "general" para que todos los involucrados en el proyecto, independientemente del lenguaje que estén empleando sepán que hacer. "Es la parte analista"
//En carpeta "ui" va todo lo relacionado a la parte visual, también los ViewModel. "Es la parte que dibuja"
//En carpeta "data" va todo lo relacionado a de donde vamos a guardar y recuperar la información, ya sea de bases de datos, APIs, ficheros, etc. "Es la parte que realmente trabaja"
//Si el proyecto es pequeño/mediano basta con las 3 capas/carpetas "data", "domain" y "data". Pero si ya es muy grande, a nivel empresa, se haría una carpeta para cada feature (login, index, cart, etc.) y para cada una se tendrían dentro las 3 carpetas ("data", "domain", "ui") correspondientes

//Para 'optimizar' los imports (quitar aquellos que se ponen por defecto pero que no emplearemos) ir a pestaña "Code"->"Optimize imports"

//Se usará la librería "Navigation component" que simplifica y gestiona la navegación entre Activitys, Fragments, etc. de una forma sencilla, comoda y segura. Lo que antes se tenía que hacer manualmente ya lo incluye la librería. Importada correspondientemente en "build.gradle.kts (Module :app)" (señalado con comentario "//NavComponent")
//Se empleará un "grafo de navegación", que es como un mapa de navgeación, donde cada punto vendrían a ser cada pantalla, y de esta forma se pueda determinar que rutas siga la aplicación en cuanto a navegación entre pantallas...
//...lo correspondiente a ello está en carpeta "navigation" creada dentro de carpeta "res" (para "main_graph.xml" clic derecho->new->Navigation Resource File)

//Algunas dependencias/librerías (como la de "Navigation Component" por ejemplo) emplean una versión de Sdk mayor, ya que por ejemplo cuando creamos este proyecto por default venía la versión 33, pero librerías como esa al querer emplearlas da error porque requieren la 34...
//...para ello, en "build.gradle.kts (Module :app)" se cambia el valor en "compileSdk =" y "targetSdk =" a 34 (en caso de que se empleen ptras que requieran versiones mayores o así pues ya se pone el valor de la versión que se indique en el mensaje de error)

//Para la parte del "palmistry" (pantalla donde esta el marco de la mano para que el usuario la coloque y vea lo de las líneas y eso) para la parte de poder usar la webcam al momento de crear el emulador se selecciona el botón "Show Advanced settings"->en parte "Camera" en las opciones de "Front" y "Back" se selecciona "Webcam0"

//Además de solo los colores también hay "selectores" los cuales se aplican a componentes que pueden tener varios estados (seleccionado, no seleccionado, etc.)...
//...un selector es como una clase, y archivo .xml, que tiene distintos colores dependiendo de los estados del componente. En este caso se creó carpeta "color" dentro de "res"->clic derecho->New->"Color Resource File" y a un archivo se nombró "bottom_nav_selector.xml"

//Para guardar el código en un repositorio de Git para no perderlo guardándolo solo de forma local, o para hacerlo colaborativo y así...
//...Clic en pestaña VCS->"Enable Version Control Integration"->Opción "Git"->OK->Abrimos terminal haciendo clic en pestaña de abajo "Terminal"->Ponemos comando "git add ."->Hacemos commit (una forma es ir a pestaña "Git"->opción "Commit..."->Se le pone una descripción, en este caso al ser la primera vez se le puso "initial commit"->"Commit"->Si es el caso presionar "Commit anyway")
//Luego, se crea un repositorio en GitHub (ya sé como, desde la página de mi GitHub, botón en "New"->Le ponemos un nombre (en este caso fue "Android-Expert-Intermedio")->Una descripción->En este caso no se añadió el README file->Se crea), copiamos el link del repositorio que aparece en pantalla que se muestra después de crearlo, luego en Android Studio damos clic en pestaña "Git"->Opción "Manage Remotes"->Se de clic en simbolo "+" y se pone el link)->OK
//Una vez hecho esto se puede hacer un "Push", vamos a pestaña "Git"->"Push"->clic en botón "Push"

//Se añadió el README.md, primero se abre la aprte de archivos, se cambia la vista de "Android" a "Project"->clic derecho sobre la carpeta raiz->New->File->"README.md" (ahí se copió lo que había en el archivo con el mismo nombre en el repositorio de Git del curso), se hizo el Commit luego el Push y ya

//Para añadir y poder emplear otras fuentes de texto distintas a la que trae Android por defecto (Roboto), es meterse a https://fonts.google.com/ -> elegir una fuente->dar clicl en ella y ya sea descargar todas las variantes (se descarga un .zip con los .ttf dentro) o una en especifíco y descragar su .ttf ->crear carpeta "font" en "res"->se coloca el archivo .ttf dentro. Y acuando se quiera utilizar esa fuente en algún texto simplemente con su atributo "fontFamily" y haciendo referencia a la fuente puesta (ej. " android:fontFamily="@font/dancing" ")

//La "inyección de dependencias" automatiza y simplifica la gestión de dependencias. Por ejemplo hay veces que para usar una clase esta emplea dos objetos, por lo que tenemos que importar las clases de las que sean estos objetos, pero para uno de ellos aparte tenemos que definirlo y crear a su vez otros 4 objetos y así. Entonces para no estar haciendo todo lo relacionado a las importaciones requeridas y así manualmente, con la inytección de dependecncias todo esto se hace "por detrás" de manera automática, ósea ya solito.
//"DaggerHilt" es la herramienta recomendada por Google para lo relacionado a la gestión de dependencias. (Importada correspondientemente en "build.gradle.kts (Module :app)" así como la explicación allí de todo lo demás que se agregó en otros lados para lo que ocupa para funcionar )
//El archivo "application" es la PRIMERA clase que se carga cuando se ejecuta un proyecto de Android. Por lo que ahí suelen ir las configuraciones "generales" de toda la aplicación...
//...en el caso de esta aplicación este archivo fue el creado a nivel carpeta "horoscapp" llamado "HoroscApp" (una práctica habitual es a estos archivos colocarles el nombre del proyecto seguido de la palabra "App", pero como este ya tenía la palabra "App" en su nombre, solo se puso una vez)...
//...en ese archivo fue donde se configuro lo de DaggerHilt para esta aplicación.
//Ahora para usar DaggerHilt en todos los componentes (clases/archivos) (Activity, Fragment, etc.) de la aplicación, se deben preparar para ser ya sea tanto "inyectados" como "inyectables" (hablando de dependencias). Las Annotation ("@...") a colocar sobre cada "class" dependen del tipo de archivo que sean, por ejemplo en algunos cuando se pone:...
//-"@AndroidEntryPoint", se indica que puede recibir cosas inyectadas
//-En el caso de los ViewModel es "@HiltViewModel" sobre su "class", esto para preparar a ese ViewModel para trabajar con DaggerHilt, y después de su nombre poner "@Inject constructor()" esto para que se pueda inyectar ahí lo que sea, donde dentro de los "()" ya irán las instancias de las clases que vayamos a requerir y ya con la funcionalidad de DaggerHilt ya este se encarga de importar o crear esas clases.

//Los Fragment corresponden a la parte visual (la que muestra el contenido), para cada uno se hace un "ViewModel" (que vendría a ser el controlador y que es el que se encarga de extraer la información que se va a mostrar en el Fragment), y como el Fragment siempre está escuchando al ViewModel, lo que esté recolectando ese ViewModel será lo que se irá mostrando en el Fragment. Los "ViewModel" irán en las respectivas carpetas correspondientes a cada módulo o parte de la aplicación, junto con su Fragment, y su nombre será el mismo solo que con "ViewModel" al final

//Para las imágenes que vayamos a emplear que no sean vectores (.svg) y transformarlos después a .xml, ósea que vengan en .png, .jpg y así, lo mejor es convertirlas a .webp, ya que es más óptimo emplearlas así porque pesan mucho menos...
//...para convertirlas se copian las imágenes en el proyecto (en este caso en carpeta "drawable")->clic derecho->opción "Convert to WebP..."->Seleccionamos la calidad que queremos conservar (entre menor sea pesará menos), dejamos la que viene por default (75%)->OK
//Esto también es una buena práctica, ya que quizás en un proyecto con pocas imágenes no se notaría mucho la diferencia, pero en proyectos muchísimo más grandes que tienen demasiados recursos estos pequeños detalles si hacen la diferencia, ya que esos kb de cada imagen que se ahorran se convierten después en más memoria si se juntan todos los kb que se ahorran por cada recurso, lo cuál mejora la eficiencia y optimización de la aplicación y no la hace tan pesada o tardada, o incluso que "truene" en dispositivos con poca capacidad.

//Para que el Fragment (parte visual) pueda estar mostrando lo que recupera el ViewModel en tiempo real, es decir para que siempre esté escuchando o esté suscrito a alguna variable, lista, etc. dentro del ViewModel y esté siendo notificado de cuando esta cambia su valor para así mostrarla otra vez ya con su nuevo o nuevos valores, se usa "StateFlow", que es básicamente como un Flow (visto en curso básico con las BD en DataStore, que es un canal de comunicación entre dos cosas, en este caso parte visual y ViewModel, donde siempre se está mandando la información, con cambios y valores agregados y demás) pero más completo...
//...un primer acercamiento a esto está explicado en "HoroscopeViewModel" y "HoroscopeFragment", ojo no es la única forma de hacer esa parte de comunicación entre Fragment y ViewModel, pero si es una y es una forma simple.

//Como se sigue usando XML en lugar de Jetpack Compose (modo más actual o recomendado en la actualidad, y más rápido porque facilita más cosas) para la parte de las vistas y demás, para los Recycler View se seguirán teniendo que crear sus respectivos Adapter y ViewHolder (visto en curso básico)
//Para las vistas correspondientes a los items de los recycler view siempre se nombran con "item_" al principio (van en carpeta "layout")

//Hay aplicaciones como esta en la que la información que se mostrará (en algunas partes) no suele cambiar en mucho tiempo, ósea que siempre es la misma durante un tiempo considerable, en este caso no se requeriría o no tendría tanto sentido obtener la información mediante Retrofit (consumo de APIs), Bases de datos, etc. sino que podría ser incluso "hardocdeada" obvio en los ficheros correspondientes especifícos para ello donde la información se encuentre ahí, y ya solo extraerla desde esos ficheros (recordar que todas las operaciones relacionadas a extraer los datos o información que se mostrará en la aplicación se hacen en la capa de "data")...
//...*Esto solo en algunas partes, como por ejemplo la pantalla inicial, la correspondiente a HoroscopeFragment, donde lo empleado para el Recycler View en su correspondiente modelo de datos (HoroscopeInfo) se recupera la información para hacer cada objeto de ficheros como "strings.xml" donde los nombres ya vienen "hardcodeados", y las imágenes del directorio "drawable". Esto cuando bien se podrían haber consumido u obtenido las URL correspondientes desde una API, pero por lo que se comentaba al ser esta información no tan "robusta" y no tan cambiante se puede hacer así. Ya en casos como por ejemplo la información de la pantalla de detalles de cada horoscopo (lo correspondiente a HoroscopeDetailActivity) si se hace el consumo de la respectiva API.
//Los modelos de datos, siguiendo estrictamente la arquitectura Clean Architecture, deberían estar en todas las capas, es decir si se tuviera un modelo "Persona" tendría que haber un modelo de Persona tanto en la capa "data", en capa "domain" y capa "ui", esto porque el modelo y lo que se va requiriendo de él puede ir cambiando dependiendo la capa. PERO en el caso de esta aplicación, al no ser tan cambiante el modelo de datos, no hará falta hacerlo así, un modelo en cada capa, sino que solo se pondrá en la de "domain", capa en la cuál generalmente irá SIEMPRE el modelo de datos "más limpio" (o general) para trabajar...
//...los modelos en este caso irán en carpeta "model" creada dentro de "domain"
//La capa que se encarga de proveer de la información necesaria a la aplicación es la de "data", "a la aplicación no le importa como esta la recupere o de donde simplemnete quiere la información", dentro de la cual iran los "provider" que son los encargados de darla. (en carpeta "providers" dentro de "data")
//Los Provider son clases que proveen la información...
//...Siguiendo Clean Architecture hay dos formas en que estas clases recuperen la información, ambas válidas:...
//... 1. Definiéndola como "caso de uso", donde es básicamente una clase que ejecuta la lógica necesaria para recopilar la información que requiere el ViewModel y proveérsela (Aunque es válida esta opción, esto a veces es como tener una clase en medio que básicamente no hace nada. SIN EMBARGO, en algunas partes del proyecto si empleamos esta forma)
//... 2. Definiéndola como un "Provider", con métodos que recolectan la información y esas clases se inyectan en los respectivos ViewModel y mediante DaggerHilt ya queda todo configurado para emplearlas

//Recomendado poner las anotations "@AndroidEntryPoint", "@HiltViewModel", etc. según corresponda al principio cuando se esté creando su clase (Ya sea Fragment, Activity, ViewModel etc.) cuando sea necesario para después no tener problemas o errores con las dependencias que no se generan al no ponerlo

//Para la parte de asociar un ViewModel a su respectivo Fragment o Activity puede ser por ejemplo así " private val horoscopeViewModel by viewModels<HoroscopeViewModel>() " o así " private val horoscopeDetailViewModel: HoroscopeDetailViewModel by viewModels() " donde en uno el tipo se pone entre los "<>" y en el otro después de los ":"

//Se usarán las funciones lambda (ya vistas en curso básico) para algunas funcionalidades relacionadas con los Recycler View, como ir a otra pantalla con detalles según el horoscopo seleccionado en el fragment "Horoscope"
//Básicamente el camino de la navegación que se tomará es que para cada feature principal (en este caso las secciones de Horoscope, Luck y Palmistry) ya para las páginas consiguientes a estas, por ejemplo la de detalles de cada horoscopo en Horoscope, serán "subniveles" y serán Activity, donde al volver se regrese a su correspondiente Fragment
//La forma de navegar entre los Fragment y sus respectivos Activity (con respecto a que se está empleando Navigation Component) puede ser de dos formas, pero la empleada acá es la más recomendable, que es con la librería "safeargs" que genera automáticamente las clases para hacer esa navegación segura. *Correspondientemente implementada en ambos buil.gradle.kts
//...Para configurar esa navegación hay que ir a "main_graph.xml" (en vista "Design") seleccionamos "New destination" (icono del celular con un "+"), seleccionamos el Activity, luego le damos clic al Fragment y seleccionamos "Add action" (icono de flecha "->") y ya ahí ponemos el destino, que sería el xml del Activity (esto en vista "code" se verá dentro del respectivo <Fragment...> en el <action...>. *Se puede modificar el valor de "ID" pero lo recomendable es dejar el que asigna Android Studio, y demás acciones como las transiciones o que cuando se quiera volver del Activity a qué pantalla en específico volver...
//...ejemplo para ya codificar la navegación entre Fragment y Activity en "HoroscopeFragment.kt"

//Para la parte de la navegación a la pantalla de detalles (HoroscopeDetailActivity) del signo o item seleccionado en HoroscopeFragment para saber qué signo se seleccionó (ya habiendo creado previamente lo necesario que era la enum class HoroscopeModel que sirve para eso, así como el when en HoroscopeFragment que lo evalúa), para pasar el tipo (variable "type") como parámetro a ese Activity (con la nevgeación que se está usando, safeargs) vamos a "main_graph.xml" en vista "Design" seleccionamos el HoroscopeDetailActivity y en menú de derecha en apartado "Arguments" seleccionamos "Add argument", damos nombre al argumento (en este caso fue "type") y en "Type" seleccionamos "Custom enum..." (NOTA: NO RECOMENDABLE USAR "Custom Parcelable..." ni "Custom Serializable..."), seleccionamos la enum class (en este caso HoroscopeModel), y damos "OK"...
//...en vista "Code" podremos ver las líneas que se agregaron (marca error en lo de "type" pero es como defecto de la versión Giraffe de Android

//Otra BUENA PRÁCTICA, que ya se había visto igual desde el curso básico, es que cuando varios items como los TextView por ejemplo tienen los mismos valores en sus atributos en cuanto al diseño lo mejor es poner esos atributos con sus respectivos valores dentro de un estilo personalizado dentro de "themes.xml" para no estar repitiendo esas líneas, además que eso también le da mantenibilidad al código, ya que cuando se cambie el estilo en general se aplicarán esos cambios a todos los items que lo tengan asignado.

//Para esta aplicación se emplearán API's, en este caso la API https://newastro.vercel.app/ (ya visto en curso básico el cómo consumirlas con Retrifit (con su respectiva implementación en build.gradle.kts), los archivos de "...service", los del modelo de datos para mapear lo del JSON a ese tipo definido acá en Kotlin, etc.

//Lo del "repositorio" (intermediario entre capa data y capa domain) y sus respectivas interfaz (en capa domain) y clase que implementa esa interfaz (capa data) se haca así ya que la capa de domain solo solicita la información que necesita la aplicación y no le importa lo que haya que hacer para consrguirla, mientras que la capa de data es la encargada de hacer lo necesario para recuperarla. En este caso más especifico, la interfaz "Repository" tiene la declaración de las funciones con respecto a lo que va a necesitar, y ya en la clase "RepositoryImpl" se lleva a cabo lo necesario para recuperar esta información...
//...esto es una buena práctica, ya que por ejemplo en este caso la capa de data (más especificamente la clase RepositoryImpl) está recuperando la información de una API mediante la librería Retrofit, pero si en un futuro tuviera que cambiar esto, ya sea que ahora fuera recuperando la información mediante otra librería, de una BD, de un archivo, etc. etc. ya solo se tendría que cambiar lo correspondiente a qué se debe hacer para recuperar esa información en la capa de "data", ya en las demás capas como "domain" y "ui" ya no se tendría que tocar nada, esto por lo ya comentado antes que estas capas solo solicitan y emplean la información que les da "data" sin importarles que tenga que emplar o cómo le haga para recuperarla.